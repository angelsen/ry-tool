# uv.yaml - Enhanced uv operations with git integration
# Usage: ry libraries/uv/uv.yaml <command> [args...]

match:
  "version --bump":
    # Enhanced bump workflow
    - shell: |
        # Check git is clean
        if [ -n "$(/usr/bin/git status --porcelain)" ]; then
            echo "ERROR: Working directory not clean" >&2
            echo "  Commit or stash changes first" >&2
            exit 1
        fi
        
        # Check changelog exists
        if [ ! -f "CHANGELOG.md" ]; then
            echo "ERROR: No CHANGELOG.md found" >&2
            echo "  Run: ry libraries/changelog/changelog.yaml init" >&2
            echo "  Then update the [Unreleased] section with your changes" >&2
            exit 1
        fi
    
    # Get old version before bump
    - shell: /usr/bin/uv version --output-format json
      capture: OLD_INFO
    - python: |
        import json
        import os
        info = json.loads(os.environ['OLD_INFO'])
        print(info['version'])
      capture: OLD_VERSION
    - python: |
        import json
        import os
        info = json.loads(os.environ['OLD_INFO'])
        print(info['package_name'])
      capture: PACKAGE_NAME
    
    # Execute the bump
    - shell: /usr/bin/uv {{args.all}}
      capture: UV_OUTPUT
    
    # Get new version after bump
    - shell: /usr/bin/uv version --output-format json
      capture: NEW_INFO
    - python: |
        import json
        import os
        info = json.loads(os.environ['NEW_INFO'])
        print(info['version'])
      capture: NEW_VERSION
    
    # Update changelog if it exists
    - shell: |
        if [ -f "CHANGELOG.md" ] && [ "$OLD_VERSION" != "$NEW_VERSION" ]; then
            # Use ry to update changelog properly
            if command -v ry >/dev/null; then
                ry changelog update "$NEW_VERSION" 2>/dev/null || true
            fi
        fi
    
    # Sync dependencies to update lockfile
    - shell: /usr/bin/uv sync --quiet
    
    # Atomic git operations
    - shell: |
        NEW_VERSION="${NEW_VERSION}"
        OLD_VERSION="${OLD_VERSION}"
        
        # Stage all changes
        /usr/bin/git add -A
        
        # Commit with package name
        /usr/bin/git commit -m "chore(${PACKAGE_NAME}): bump version from ${OLD_VERSION} to ${NEW_VERSION}"
        
        # Tag with package name
        TAG_NAME="${PACKAGE_NAME}-v${NEW_VERSION}"
        /usr/bin/git tag "${TAG_NAME}" -m "Release ${PACKAGE_NAME} v${NEW_VERSION}"
        
        echo "✓ Bumped ${PACKAGE_NAME}: ${OLD_VERSION} → ${NEW_VERSION}" >&2
        echo "✓ Created tag: ${TAG_NAME}" >&2
        echo "" >&2
        echo "Next steps:" >&2
        echo "  git push origin main" >&2
        echo "  git push origin ${TAG_NAME}" >&2
    
    # Show uv output
    - shell: echo "$UV_OUTPUT"

  version:
    # Handle all version commands
    - shell: |
        # If no version argument, just show current version and exit
        if [ -z "{{args.rest|}}" ]; then
            /usr/bin/uv version
            exit 0
        fi
        
        # Otherwise continue with version setting workflow
        # Check git is clean
        if [ -n "$(/usr/bin/git status --porcelain)" ]; then
            echo "ERROR: Working directory not clean" >&2
            echo "  Commit or stash changes first" >&2
            exit 1
        fi
        
        # Check changelog exists
        if [ ! -f "CHANGELOG.md" ]; then
            echo "ERROR: No CHANGELOG.md found" >&2
            echo "  Run: ry libraries/changelog/changelog.yaml init" >&2
            echo "  Then update the [Unreleased] section with your changes" >&2
            exit 1
        fi
    
    # Get old version before setting
    - shell: /usr/bin/uv version --output-format json
      capture: OLD_INFO
    - python: |
        import json
        import os
        info = json.loads(os.environ['OLD_INFO'])
        print(info['version'])
      capture: OLD_VERSION
    - python: |
        import json
        import os
        info = json.loads(os.environ['OLD_INFO'])
        print(info['package_name'])
      capture: PACKAGE_NAME
    
    # Set the new version
    - shell: /usr/bin/uv {{args.all}}
      capture: UV_OUTPUT
    
    # Get new version after setting
    - shell: /usr/bin/uv version --output-format json
      capture: NEW_INFO
    - python: |
        import json
        import os
        info = json.loads(os.environ['NEW_INFO'])
        print(info['version'])
      capture: NEW_VERSION
    
    # Update changelog
    - shell: |
        if [ -f "CHANGELOG.md" ] && [ "$OLD_VERSION" != "$NEW_VERSION" ]; then
            # Use ry to update changelog properly
            if command -v ry >/dev/null; then
                ry changelog update "$NEW_VERSION" 2>/dev/null || true
            fi
        fi
    
    # Sync dependencies to update lockfile
    - shell: /usr/bin/uv sync --quiet
    
    # Atomic git operations
    - shell: |
        NEW_VERSION="${NEW_VERSION}"
        OLD_VERSION="${OLD_VERSION}"
        
        # Stage all changes
        /usr/bin/git add -A
        
        # Tag with package name
        TAG_NAME="${PACKAGE_NAME}-v${NEW_VERSION}"
        
        # Determine if this is initial version or version change
        if [ "$OLD_VERSION" = "0.0.0" ] || [ -z "$(/usr/bin/git tag -l)" ]; then
            # Initial version
            /usr/bin/git commit -m "chore(${PACKAGE_NAME}): initial version ${NEW_VERSION}"
        else
            # Version change
            /usr/bin/git commit -m "chore(${PACKAGE_NAME}): set version from ${OLD_VERSION} to ${NEW_VERSION}"
        fi
        
        # Tag
        /usr/bin/git tag "${TAG_NAME}" -m "Release ${PACKAGE_NAME} v${NEW_VERSION}"
        
        echo "✓ Set ${PACKAGE_NAME}: ${OLD_VERSION} → ${NEW_VERSION}" >&2
        echo "✓ Created tag: ${TAG_NAME}" >&2
        echo "" >&2
        echo "Next steps:" >&2
        echo "  git push origin main" >&2
        echo "  git push origin ${TAG_NAME}" >&2
    
    # Show uv output
    - shell: echo "$UV_OUTPUT"
  
  publish:
    # Enhanced publish with pre-flight checks
    - python: |
        import sys
        import subprocess
        from pathlib import Path
        
        # Check if current version is tagged
        result = subprocess.run(
            ["/usr/bin/uv", "version", "--output-format", "json"],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            import json
            data = json.loads(result.stdout)
            version = data['version']
            package = data['package_name']
            tag = f"{package}-v{version}"
            
            # Check if tag exists
            tag_check = subprocess.run(
                ["/usr/bin/git", "tag", "-l", tag],
                capture_output=True,
                text=True
            )
            
            if not tag_check.stdout.strip():
                print(f"ERROR: Version {version} is not tagged", file=sys.stderr)
                print(f"  Expected tag: {tag}", file=sys.stderr)
                print(f"  Run: uv version --bump patch", file=sys.stderr)
                sys.exit(1)
            
            print(f"✓ Version {version} is tagged", file=sys.stderr)
    
    # Run the actual publish
    - shell: /usr/bin/uv {{args.all}}
  
  build:
    # Clean dist directory before building
    - shell: |
        if [ -d "dist" ]; then
            echo "Cleaning dist/ directory..." >&2
            rm -rf dist/*
        fi
    
    # Run the build
    - shell: /usr/bin/uv {{args.all}}
  
  # Pass through all other commands unchanged
  default:
    - shell: /usr/bin/uv {{args.all}}