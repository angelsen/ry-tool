version: "2.0"
name: uv
type: augmentation
target: /usr/bin/uv
description: Python package management with automated version workflows

workflows:
  - "ry-next uv version --bump patch --dry-run  # Preview version bump"
  - "BUMP_TOKEN=xxx ry-next uv version --bump patch  # Execute bump"
  - "ry-next uv build                        # Build package"
  - "ry-next uv publish --dry-run            # Verify publish requirements"
  - "PUBLISH_TOKEN=xxx ry-next uv publish    # Publish to PyPI"

commands:
  # Version management with token-based workflow
  version:
    description: Version management with automated git workflow
    arguments:
      version: optional
    flags:
      bump:
        type: enum
        values: [major, minor, patch, stable, alpha, beta, rc, post, dev]
        description: Bump version type
      package: 
        type: string
        description: Package name for workspace
    
    handlers:
      # Dry-run mode - preview changes and generate token
      - when: "flags.get('bump') and flags.get('dry-run')"
        augment:
          before:
            - python: |
                from version_workflow import check_git_clean, check_changelog_exists, get_current_version
                
                # Check git status
                if not check_git_clean():
                    print("‚ùå Working directory not clean", file=sys.stderr)
                    print("   Commit or stash changes first", file=sys.stderr)
                    sys.exit(1)
                
                # Check CHANGELOG has content to release
                from pathlib import Path
                from changelog_core import has_unreleased_content
                
                if Path('CHANGELOG.md').exists():
                    if not has_unreleased_content():
                        print("‚ö†Ô∏è  CHANGELOG.md has no unreleased changes", file=sys.stderr)
                        print("   Add changes under [Unreleased] before bumping", file=sys.stderr)
                else:
                    print("‚ö†Ô∏è  No CHANGELOG.md found", file=sys.stderr)
                
                # Get package info for display
                package = flags.get('package')
                version, package_name = get_current_version(package)
                bump_type = flags.get('bump', 'patch')
                
                print(f"üì¶ Preview: {package_name} version bump ({bump_type})", file=sys.stderr)
                
                # Check for changelog
                changelog = check_changelog_exists(package)
                if changelog:
                    print(f"üìù Will update: {changelog}", file=sys.stderr)
                else:
                    print("‚ö†Ô∏è  No CHANGELOG.md found", file=sys.stderr)
          
          relay: native  # Let uv show "0.1.0 => 0.1.1"
          
          after:
            - python: |
                # Generate token for actual bump
                from token_manager import TokenManager
                
                package = flags.get('package')
                bump_type = flags.get('bump', 'patch')
                
                # Get the new version from uv's output (it was just shown)
                from version_workflow import get_current_version
                version, package_name = get_current_version(package)
                
                tm = TokenManager("uv")
                token, expires = tm.generate_token(f"bump {package_name} {bump_type}")
                
                print(f"\nüìã BUMP_TOKEN={token}", file=sys.stderr)
                print(f"   Expires in {expires} seconds", file=sys.stderr)
                
                # Build the command without --dry-run
                cmd_parts = ['BUMP_TOKEN=' + token, 'uv', 'version', '--bump', bump_type]
                if package:
                    cmd_parts.extend(['--package', package])
                print(f"   Use: {' '.join(cmd_parts)}", file=sys.stderr)
      
      # Actual bump - require token and execute full workflow
      - when: "flags.get('bump') and not flags.get('dry-run')"
        augment:
          before:
            - python: |
                import sys
                # Check for bump token
                import os
                token = os.environ.get('BUMP_TOKEN', '')
                
                if not token:
                    print("‚ùå Preview version changes first", file=sys.stderr)
                    bump_type = flags.get('bump', 'patch')
                    package = flags.get('package')
                    
                    cmd_parts = ['uv', 'version', '--bump', bump_type, '--dry-run']
                    if package:
                        cmd_parts.extend(['--package', package])
                    print(f"   Run: {' '.join(cmd_parts)}", file=sys.stderr)
                    print(f"   Then use the BUMP_TOKEN provided", file=sys.stderr)
                    sys.exit(1)
                
                from token_manager import TokenManager
                
                tm = TokenManager("uv")
                if not tm.verify_token(token):
                    print("‚ùå Invalid or expired token", file=sys.stderr)
                    print("   Run with --dry-run first to get a new token", file=sys.stderr)
                    sys.exit(1)
                
                print("‚úÖ Bump token verified", file=sys.stderr)
                
                # Check CHANGELOG has unreleased content
                from pathlib import Path
                from changelog_core import has_unreleased_content
                
                if Path('CHANGELOG.md').exists():
                    if not has_unreleased_content():
                        print("‚ùå CHANGELOG.md has no unreleased changes", file=sys.stderr)
                        print("   Add your changes under [Unreleased] section", file=sys.stderr)
                        print("   Or run: ry-next changelog validate", file=sys.stderr)
                        sys.exit(1)
                    
                    print("‚úÖ CHANGELOG has unreleased content", file=sys.stderr)
                
                # Check git clean
                from version_workflow import check_git_clean
                
                if not check_git_clean():
                    print("‚ùå Working directory not clean", file=sys.stderr)
                    sys.exit(1)
                
                # Store old version for later
                from version_workflow import get_current_version
                package = flags.get('package')
                old_version, package_name = get_current_version(package)
                os.environ['RY_OLD_VERSION'] = old_version
                os.environ['RY_PACKAGE_NAME'] = package_name
          
          relay: native  # Execute the actual bump
          
          after:
            - python: |
                import subprocess
                
                from version_workflow import (
                    get_current_version, check_changelog_exists, 
                    release_changelog, commit_version_bump
                )
                
                # Get the new version after bump
                package = flags.get('package')
                new_version, package_name = get_current_version(package)
                old_version = env.get('RY_OLD_VERSION', '0.0.0')
                
                print(f"üì¶ Bumped {package_name}: {old_version} ‚Üí {new_version}", file=sys.stderr)
                
                # Update changelog if exists
                changelog = check_changelog_exists(package)
                if changelog:
                    if release_changelog(new_version, changelog):
                        print(f"üìù Updated changelog for {new_version}", file=sys.stderr)
                    else:
                        print(f"‚ö†Ô∏è  Could not update changelog", file=sys.stderr)
                
                # Sync dependencies
                print("üîÑ Syncing dependencies...", file=sys.stderr)
                subprocess.run(['/usr/bin/uv', 'sync', '--quiet'], check=False)
                
                # Commit and tag
                commit_version_bump(package_name, old_version, new_version)
      
      # Set specific version (less common, but supported)
      - when: arguments.version
        augment:
          before:
            - python: |
                import sys
                import subprocess
                
                # Check git clean
                result = subprocess.run(['/usr/bin/git', 'status', '--porcelain'], 
                                      capture_output=True, text=True)
                if result.stdout.strip():
                    print("‚ùå Working directory not clean", file=sys.stderr)
                    sys.exit(1)
          
          relay: native
          
          after:
            - python: |
                import sys
                import subprocess
                from pathlib import Path
                
                # Get new version info
                cmd = ['/usr/bin/uv', 'version', '--output-format', 'json']
                if flags.get('package'):
                    cmd.extend(['--package', flags['package']])
                
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    import json
                    data = json.loads(result.stdout)
                    version = data['version']
                    name = data['package_name']
                    
                    # Commit the change
                    subprocess.run(['/usr/bin/git', 'add', '-A'], check=False)
                    subprocess.run(['/usr/bin/git', 'commit', '-m', 
                                  f'chore({name}): set version to {version}'], check=False)
                    print(f"‚úÖ Version set to {version}", file=sys.stderr)
      
      # Default: just show version (relay all other flags like --output-format json)
      - default:
        relay: native

  # Build with safety checks
  build:
    description: Build package with safety checks
    relay: native
    augment:
      before:
        - python: |
            import sys
            import subprocess
            from pathlib import Path
            
            # Check git status (warning only)
            result = subprocess.run(['/usr/bin/git', 'status', '--porcelain'],
                                  capture_output=True, text=True)
            if result.stdout.strip():
                print("‚ö†Ô∏è  Building from dirty working tree", file=sys.stderr)
                print("   Uncommitted changes may be included", file=sys.stderr)
            
            # Check if dist is empty
            dist_dir = Path('dist')
            if flags.get('package'):
                # Use package name from flags
                dist_dir = Path(f'packages/{flags.get("package")}/dist')
            
            if dist_dir.exists() and list(dist_dir.glob('*')):
                print(f"‚ùå {dist_dir} is not empty", file=sys.stderr)
                print(f"   Clean with: rm -rf {dist_dir}/*", file=sys.stderr)
                sys.exit(1)
      
      after:
        - shell: |
            echo "‚úÖ Build complete" >&2
            echo "   Next: uv publish --dry-run" >&2

  # Publish with token-based safety
  publish:
    description: Publish to PyPI with safety checks
    
    handlers:
      # Dry-run mode - verify and generate token
      - when: "flags.get('dry-run')"
        augment:
          before:
            - python: |
                from version_workflow import check_publish_requirements
                
                # Get package from flags if specified
                package = flags.get('package')
                
                ready, error = check_publish_requirements(package)
                
                if not ready:
                    print(f"‚ùå Not ready to publish: {error}", file=sys.stderr)
                    sys.exit(1)
                
                print("‚úÖ Ready to publish", file=sys.stderr)
                
                # Check for PyPI token - try pass if not in env
                if not env.get('UV_PUBLISH_TOKEN'):
                    import subprocess
                    result = subprocess.run(['pass', 'pypi/uv-publish'], 
                                          capture_output=True, text=True)
                    if result.returncode == 0:
                        print("üîë Will use PyPI token from pass", file=sys.stderr)
                    else:
                        print("‚ö†Ô∏è  No UV_PUBLISH_TOKEN set and pass pypi/uv-publish not found", file=sys.stderr)
                        print("   Set with: export UV_PUBLISH_TOKEN=pypi-...", file=sys.stderr)
                        print("   Or store in pass: pass insert pypi/uv-publish", file=sys.stderr)
          
          relay: native  # Let uv show what would be published
          
          after:
            - python: |
                # Generate publish token
                from token_manager import TokenManager
                
                tm = TokenManager("uv")
                token, expires = tm.generate_token("publish to PyPI")
                
                print(f"\nüìã PUBLISH_TOKEN={token}", file=sys.stderr)
                print(f"   Expires in {expires} seconds", file=sys.stderr)
                
                # Build command without --dry-run
                cmd_parts = ['PUBLISH_TOKEN=' + token, 'uv', 'publish']
                # Add package flag if present
                if flags.get('package'):
                    cmd_parts.extend(['--package', flags.get('package')])
                # Note: other flags will be passed through relay
                
                print(f"   Use: {' '.join(cmd_parts)}", file=sys.stderr)
      
      # Actual publish - require token
      - when: "not flags.get('dry-run')"
        augment:
          before:
            - python: |
                import sys
                # Check for publish token
                import os
                token = os.environ.get('PUBLISH_TOKEN', '')
                
                if not token:
                    print("‚ùå Verify publish requirements first", file=sys.stderr)
                    print("   Run: uv publish --dry-run", file=sys.stderr)
                    print("   Then use the PUBLISH_TOKEN provided", file=sys.stderr)
                    sys.exit(1)
                
                from token_manager import TokenManager
                
                tm = TokenManager("uv")
                if not tm.verify_token(token):
                    print("‚ùå Invalid or expired token", file=sys.stderr)
                    print("   Run: uv publish --dry-run", file=sys.stderr)
                    sys.exit(1)
                
                print("‚úÖ Publish token verified", file=sys.stderr)
                
                # Ensure PyPI token is set - try pass if not in env
                if not env.get('UV_PUBLISH_TOKEN'):
                    import subprocess
                    # Try to get from pass
                    result = subprocess.run(['pass', 'pypi/uv-publish'], 
                                          capture_output=True, text=True)
                    if result.returncode == 0:
                        os.environ['UV_PUBLISH_TOKEN'] = result.stdout.strip()
                        print("üîë Retrieved PyPI token from pass", file=sys.stderr)
                    else:
                        print("‚ùå UV_PUBLISH_TOKEN not set and pass pypi/uv-publish not found", file=sys.stderr)
                        print("   Set with: export UV_PUBLISH_TOKEN=pypi-...", file=sys.stderr)
                        print("   Or store in pass: pass insert pypi/uv-publish", file=sys.stderr)
                        sys.exit(1)
          
          relay: native
          
          after:
            - shell: |
                echo "üéâ Published successfully!" >&2

  # All other uv commands automatically relay to native uv