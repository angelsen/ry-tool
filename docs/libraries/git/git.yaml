# git.yaml - Enhanced git workflow with validation  
# Usage: ry libraries/git/git.yaml <command> [args...]

match:
  "diff --stat --staged":
    # Show summary of staged changes and generate review token
    - shell: "{{env.RY_GIT|/usr/bin/git}} diff --stat --staged"
    - python: |
        import sys
        import pathlib
        import os
        
        # Generate token for staged changes
        lib_path = pathlib.Path(os.environ['RY_LIBRARY_DIR']) / 'lib'
        sys.path.insert(0, str(lib_path))
        from token import get_current_token
        
        token, expires = get_current_token()
        if token:
            print(f"\nREVIEW_TOKEN={token}", file=sys.stderr)
            print(f"# Expires in {expires} seconds", file=sys.stderr)
  
  "commit -m":
    # Check review token - use !env to get it at YAML parse time
    - python: |
        import sys
        import pathlib
        import os
        
        # Token passed from environment at ry invocation time
        token = "{{env.REVIEW_TOKEN|}}"
        
        if not token:
            print("ERROR: Review staged changes first", file=sys.stderr)
            print("  Run: git diff --stat --staged", file=sys.stderr) 
            print("  Then: REVIEW_TOKEN=<token> git commit -m 'message'", file=sys.stderr)
            sys.exit(1)
        
        lib_path = pathlib.Path(os.environ['RY_LIBRARY_DIR']) / 'lib'
        sys.path.insert(0, str(lib_path))
        from token import verify_token
        
        if not verify_token(token):
            print("ERROR: Invalid or expired token", file=sys.stderr)
            print("  Run: git diff --stat --staged", file=sys.stderr)
            sys.exit(1)
    
    # Validate and clean commit message
    - python: |
        import sys
        import subprocess
        import os
        
        # Get commit message from args (now args.0 after "commit -m" is consumed)
        msg = """{{args.0|}}"""
        if not msg:
            print("ERROR: No commit message provided", file=sys.stderr)
            print("  Usage: git commit -m 'message'", file=sys.stderr)
            sys.exit(1)
        
        # Import our validators
        import pathlib
        lib_path = pathlib.Path(os.environ['RY_LIBRARY_DIR']) / 'lib'
        sys.path.insert(0, str(lib_path))
        from strip_claude import strip_signatures
        from validate_commit import validate_conventional
        
        # Clean the message
        cleaned = strip_signatures(msg)
        if cleaned != msg:
            print("WARNING: Removed AI signatures from commit message", file=sys.stderr)
        
        # Validate format
        is_valid, error = validate_conventional(cleaned)
        if not is_valid:
            print(f"ERROR: {error}", file=sys.stderr)
            print("  Example: feat: add new feature", file=sys.stderr)
            print("  Example: fix(api): handle null response", file=sys.stderr)
            sys.exit(1)
        
        # Output cleaned message
        print(cleaned)
      capture: CLEAN_MSG
    
    # Commit with cleaned message
    - shell: '{{env.RY_GIT|/usr/bin/git}} commit -m "$CLEAN_MSG"'
      base64: false  # Disable encoding to allow variable expansion
  
  add:
    - shell: "{{env.RY_GIT|/usr/bin/git}} add {{args.all}}"
    - shell: |
        if [ -n "$({{env.RY_GIT|/usr/bin/git}} diff --staged --name-only)" ]; then
            echo "INFO: Files staged successfully" >&2
            echo "  1. Review: git diff --stat --staged  (generates token)" >&2
            echo "  2. Commit: REVIEW_TOKEN=<token> git commit -m 'type: description'" >&2
        fi
  
  status:
    - shell: "{{env.RY_GIT|/usr/bin/git}} status {{args.all|}}"
  
  tag:
    # Enhanced tag with changelog integration
    - python: |
        import sys
        import subprocess
        import os
        from pathlib import Path
        
        # Get tag name from args
        tag_name = "{{args.0|}}"
        if not tag_name:
            # No tag name provided, list tags
            subprocess.run(["{{env.RY_GIT|/usr/bin/git}}", "tag", "{{args.all|}}"])
            sys.exit(0)
        
        # Extract version from tag name (v1.2.0 -> 1.2.0)
        version = tag_name[1:] if tag_name.startswith('v') else tag_name
        
        # Check if this looks like a version tag
        import re
        if not re.match(r'^\d+\.\d+\.\d+', version):
            # Not a version tag, pass through
            print(f"INFO: Non-version tag, skipping changelog integration", file=sys.stderr)
            sys.exit(0)
        
        # Check if CHANGELOG.md exists
        if Path("CHANGELOG.md").exists():
            print(f"INFO: Updating changelog for version {version}...", file=sys.stderr)
            
            # Try to bump changelog
            result = subprocess.run(
                ["ry", "changelog", "bump", version],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                # Changelog updated successfully, commit it
                subprocess.run(["{{env.RY_GIT|/usr/bin/git}}", "add", "CHANGELOG.md"], check=True)
                subprocess.run(
                    ["{{env.RY_GIT|/usr/bin/git}}", "commit", "-m", f"chore: update changelog for {tag_name}"],
                    check=True
                )
                print(f"SUCCESS: Changelog updated and committed", file=sys.stderr)
            else:
                print(f"WARNING: Could not update changelog", file=sys.stderr)
                print(f"  {result.stderr.strip()}", file=sys.stderr)
        else:
            print(f"INFO: No CHANGELOG.md found, creating tag without changelog", file=sys.stderr)
    
    # Create the actual tag
    - shell: |
        TAG_NAME="{{args.0|}}"
        
        # Skip if no tag name (already handled above)
        if [ -z "$TAG_NAME" ]; then
            exit 0
        fi
        
        # Check if -m flag is present
        HAS_MESSAGE=false
        MESSAGE=""
        SKIP_NEXT=false
        
        for arg in {{args.all|}}; do
            if [ "$SKIP_NEXT" = "true" ]; then
                MESSAGE="$arg"
                SKIP_NEXT=false
                continue
            fi
            
            if [ "$arg" = "-m" ]; then
                HAS_MESSAGE=true
                SKIP_NEXT=true
            fi
        done
        
        if [ "$HAS_MESSAGE" = "true" ] && [ -n "$MESSAGE" ]; then
            # User provided message
            {{env.RY_GIT|/usr/bin/git}} tag "$TAG_NAME" -m "$MESSAGE"
        else
            # Auto-annotate with release message
            {{env.RY_GIT|/usr/bin/git}} tag "$TAG_NAME" -m "Release $TAG_NAME"
            echo "INFO: Created annotated tag with message: Release $TAG_NAME" >&2
        fi
        
        echo "SUCCESS: Tagged as $TAG_NAME" >&2
        echo "" >&2
        echo "Next steps:" >&2
        echo "  git push origin $TAG_NAME" >&2
  
  push:
    # Check if on main/master
    - shell: |
        BRANCH=$({{env.RY_GIT|/usr/bin/git}} branch --show-current)
        if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
            echo "ERROR: Direct push to $BRANCH blocked" >&2
            echo "  Create a feature branch instead:" >&2
            echo "    git checkout -b feature/name" >&2
            echo "    git push -u origin feature/name" >&2
            exit 1
        fi
    - shell: "{{env.RY_GIT|/usr/bin/git}} push {{args.all|}}"
  
  "--ry-version":
    - shell: echo "{{library_name}} version {{library_version}}"
  
  # Pass through everything else
  default:
    - shell: "{{env.RY_GIT|/usr/bin/git}} {{args.all}}"