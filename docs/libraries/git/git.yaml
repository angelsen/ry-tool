version: "2.0"
name: git
type: augmentation
target: /usr/bin/git
description: Git workflow with review tokens and commit validation

workflows:
  - "ry-next git add .                        # Stage files"
  - "ry-next git diff --staged                # Review and get token"
  - "REVIEW_TOKEN=xxx ry-next git commit -m 'message'  # Commit with token"
  - "ry-next git push --dry-run               # Preview push"
  - "ry-next git tag v1.0.0                   # Tag with changelog update"

commands:
  # Show staged changes and generate review token
  diff:
    description: Show diff with token generation for --staged
    relay: native
    augment:
      after:
        - python: |
            # Only generate tokens for staged diff
            if flags.get('staged') or flags.get('cached'):
                from token_manager import generate_review_token, TokenManager
                
                # Generate regular commit token
                token, expires = generate_review_token("staged changes")
                print(f"REVIEW: REVIEW_TOKEN={token}", file=sys.stderr)
                print(f"   Expires in {expires} seconds", file=sys.stderr)
                print(f"   Use: REVIEW_TOKEN={token} git commit -m 'message'", file=sys.stderr)
                
                # Also generate amend token
                tm = TokenManager("git-amend")
                amend_token, amend_expires = tm.generate_token("amend commit")
                print(f"REVIEW: AMEND_TOKEN={amend_token}", file=sys.stderr)
                print(f"   Expires in {amend_expires} seconds", file=sys.stderr)
                print(f"   Use: AMEND_TOKEN={amend_token} git commit --amend", file=sys.stderr)

  # Commit with token requirement and validation
  commit:
    description: Commit with review token and message validation
    flags:
      m/message: string
      amend: bool
    
    handlers:
      # Amend commits also need token (they change history)
      - when: flags.amend
        augment:
          before:
            - python: |
                import sys
                # Check for amend token
                import os
                token = os.environ.get('AMEND_TOKEN', '')
                
                if not token:
                    print("ERROR: Review changes before amending", file=sys.stderr)
                    print("   Run: git diff --staged", file=sys.stderr)
                    sys.exit(1)
                
                from token_manager import TokenManager
                
                tm = TokenManager("git-amend")
                if not tm.verify_token(token):
                    print("ERROR: Invalid or expired amend token", file=sys.stderr)
                    print("   Generate with: git diff --staged", file=sys.stderr)
                    sys.exit(1)
                
                print("SUCCESS: Amend token verified", file=sys.stderr)
            
            # If message provided, validate it
            - python: |
                message = flags.get('m')
                if message:
                    from commit_validator import process_commit_message
                    
                    cleaned, warnings = process_commit_message(message)
                    
                    # Show warnings but don't block
                    for warning in warnings:
                        print(f"WARNING: {warning}", file=sys.stderr)
                    
                    # Update the flag with cleaned message
                    flags['m'] = cleaned
                    if cleaned != message:
                        print("INFO: Message cleaned", file=sys.stderr)
          
          relay: native
          
          after:
            - shell: 'echo "SUCCESS: Commit amended successfully" >&2'
      
      # Regular commit (not amend)
      - default:
        augment:
          before:
            - require: flags.m
              error: "Commit message required. Use: git commit -m 'type: description'"
            
            # Check review token
            - python: |
                import sys
                import os
                token = os.environ.get('REVIEW_TOKEN', '')
                
                if not token:
                    print("ERROR: Review staged changes first", file=sys.stderr)
                    print("   Run: git diff --staged", file=sys.stderr)
                    print("   Then: REVIEW_TOKEN=<token> git commit -m 'message'", file=sys.stderr)
                    sys.exit(1)
                
                from token_manager import verify_review_token
                
                if not verify_review_token(token):
                    print("ERROR: Invalid or expired token", file=sys.stderr)
                    print("   Run: git diff --staged", file=sys.stderr)
                    sys.exit(1)
                
                print("SUCCESS: Review token verified", file=sys.stderr)
            
            # Validate and clean commit message
            - python: |
                message = flags.get('m', '')
                
                from commit_validator import process_commit_message
                
                cleaned, warnings = process_commit_message(message)
                
                # Show warnings but don't block
                for warning in warnings:
                    print(f"WARNING: {warning}", file=sys.stderr)
                
                # Update the flag with cleaned message
                flags['m'] = cleaned
                if cleaned != message:
                    print("INFO: Message cleaned", file=sys.stderr)
          
          relay: native
          
          after:
            - shell: 'echo "SUCCESS: Committed successfully" >&2'

  # Tag with changelog integration for version tags
  tag:
    description: Create tags with automatic changelog release
    arguments:
      tagname: optional
    flags:
      m/message: string
      d/delete: bool
      l/list: bool
    
    handlers:
      # List or delete tags - just pass through
      - when: "flags.l or flags.d"
        relay: native
      
      # Create version tag with changelog
      - when: "arguments.tagname and not flags.d"
        augment:
          before:
            - python: |
                import re
                import subprocess
                from pathlib import Path
                
                tag_name = arguments.get('tagname', '')
                
                # Check if it's a version tag
                version_pattern = r'^v?\d+\.\d+\.\d+'
                if not re.match(version_pattern, tag_name):
                    # Not a version tag, skip augmentation
                    sys.exit(0)
                
                # Extract version number
                version = tag_name[1:] if tag_name.startswith('v') else tag_name
                
                # Check for CHANGELOG.md
                if Path('CHANGELOG.md').exists():
                    # Check it has unreleased content before tagging
                    from changelog_core import has_unreleased_content
                    
                    if not has_unreleased_content():
                        print("ERROR: CHANGELOG.md has no unreleased changes", file=sys.stderr)
                        print("   Add your changes under [Unreleased] section", file=sys.stderr)
                        print("   Then tag with: git tag " + tag_name, file=sys.stderr)
                        sys.exit(1)
                    print(f"BUILD: Releasing version {version} in changelog...", file=sys.stderr)
                    
                    # Use changelog library directly
                    from changelog_core import release_version
                    
                    if release_version(version, None):  # None = use today's date
                        # Commit the changelog update
                        subprocess.run(['/usr/bin/git', 'add', 'CHANGELOG.md'], check=False)
                        subprocess.run(
                            ['/usr/bin/git', 'commit', '-m', f'chore: release version {version}'],
                            check=False
                        )
                        print(f"SUCCESS: Changelog updated for {version}", file=sys.stderr)
                    else:
                        print(f"WARNING: Could not update changelog: {result.stderr}", file=sys.stderr)
          
          relay: native
          
          after:
            - shell: |
                echo "SUCCESS: Tagged: {{arguments.tagname}}" >&2
                echo "INFO: Push with: git push origin {{arguments.tagname}}" >&2
      
      # Default: just pass through
      - default:
        relay: native

  # Push with branch protection
  push:
    description: Push with branch protection and preview support
    augment:
      before:
        - python: |
            import sys
            import subprocess
            
            # Skip warnings for --dry-run
            if flags.get('dry-run'):
                print("INFO: Preview mode - showing what would be pushed", file=sys.stderr)
                sys.exit(0)  # Let native git handle the dry-run
            
            # Get current branch
            result = subprocess.run(
                ['/usr/bin/git', 'branch', '--show-current'],
                capture_output=True,
                text=True
            )
            
            branch = result.stdout.strip()
            
            # Check if pushing to protected branch
            protected = ['main', 'master']
            if branch in protected:
                # Only warn if not explicitly specified
                if branch not in str(remaining_args) and 'origin' not in str(remaining_args):
                    print(f"WARNING: Direct push to {branch} branch", file=sys.stderr)
                    print(f"   Consider creating a feature branch:", file=sys.stderr)
                    print(f"     git checkout -b feature/name", file=sys.stderr)
                    print(f"     git push -u origin feature/name", file=sys.stderr)
                    print(f"   Or preview: git push --dry-run", file=sys.stderr)
                    print(f"   Or explicitly push: git push origin {branch}", file=sys.stderr)
                    # Don't block, just warn
      
      relay: native
      
      after:
        - python: |
            import sys
            
            # Success message (won't run for --dry-run as we exit early)
            if flags.get('tags') or flags.get('follow-tags'):
                print("SUCCESS: Pushed with tags", file=sys.stderr)
            else:
                print("SUCCESS: Pushed successfully", file=sys.stderr)
  
  # Add command - augment to show hint after staging
  add:
    relay: native
    augment:
      after:
        - shell: |
            if [ -n "$(/usr/bin/git diff --staged --name-only 2>/dev/null)" ]; then
                echo "INFO: Files staged" >&2
                echo "   Review: git diff --staged --stat" >&2
                echo "   Get token: git diff --staged" >&2
                echo "TIP: Use Task agent to summarize large changes" >&2
            fi
  
  # Default: pass through all other git commands
  default:
    relay: native