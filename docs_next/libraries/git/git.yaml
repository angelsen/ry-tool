version: "2.0"
name: git
type: augmentation
target: /usr/bin/git
description: Git workflow with review tokens and commit validation

commands:
  # Show staged changes and generate review token
  diff:
    description: Show diff with token generation for --staged
    relay: native
    augment:
      after:
        - python: |
            import sys
            import os
            
            # Only generate tokens for staged diff
            if flags.get('staged') or flags.get('cached'):
                sys.path.insert(0, os.path.join(env['RY_LIBRARY_DIR'], 'lib'))
                from token_manager import generate_review_token, TokenManager
                
                # Generate regular commit token
                token, expires = generate_review_token("staged changes")
                print(f"\nüìã REVIEW_TOKEN={token}", file=sys.stderr)
                print(f"   Expires in {expires} seconds", file=sys.stderr)
                print(f"   Use: REVIEW_TOKEN={token} git commit -m 'message'", file=sys.stderr)
                
                # Also generate amend token
                tm = TokenManager("git-amend")
                amend_token, amend_expires = tm.generate_token("amend commit")
                print(f"\nüìù AMEND_TOKEN={amend_token}", file=sys.stderr)
                print(f"   Expires in {amend_expires} seconds", file=sys.stderr)
                print(f"   Use: AMEND_TOKEN={amend_token} git commit --amend", file=sys.stderr)

  # Commit with token requirement and validation
  commit:
    description: Commit with review token and message validation
    flags:
      m/message: string
      amend: bool
    
    handlers:
      # Amend commits also need token (they change history)
      - when: flags.amend
        augment:
          before:
            - python: |
                import sys
                import os
                
                # Check for amend token
                token = os.environ.get('AMEND_TOKEN', '')
                
                if not token:
                    print("‚ùå Review changes before amending", file=sys.stderr)
                    print("   Run: git diff --staged", file=sys.stderr)
                    sys.exit(1)
                
                sys.path.insert(0, os.path.join(env['RY_LIBRARY_DIR'], 'lib'))
                from token_manager import TokenManager
                
                tm = TokenManager("git-amend")
                if not tm.verify_token(token):
                    print("‚ùå Invalid or expired amend token", file=sys.stderr)
                    print("   Generate with: git diff --staged", file=sys.stderr)
                    sys.exit(1)
                
                print("‚úÖ Amend token verified", file=sys.stderr)
            
            # If message provided, validate it
            - python: |
                import sys
                import os
                
                message = flags.get('m')
                if message:
                    sys.path.insert(0, os.path.join(env['RY_LIBRARY_DIR'], 'lib'))
                    from commit_validator import process_commit_message
                    
                    cleaned, warnings = process_commit_message(message)
                    
                    # Show warnings but don't block
                    for warning in warnings:
                        print(f"‚ö†Ô∏è  {warning}", file=sys.stderr)
                    
                    # Update the flag with cleaned message
                    flags['m'] = cleaned
                    if cleaned != message:
                        print(f"‚úèÔ∏è  Message cleaned", file=sys.stderr)
          
          relay: native
          
          after:
            - shell: |
                echo "‚úÖ Commit amended successfully" >&2
      
      # Regular commit (not amend)
      - default:
        augment:
          before:
            - require: flags.m
              error: "Commit message required. Use: git commit -m 'type: description'"
            
            # Check review token
            - python: |
                import sys
                import os
                
                token = os.environ.get('REVIEW_TOKEN', '')
                
                if not token:
                    print("‚ùå Review staged changes first", file=sys.stderr)
                    print("   Run: git diff --staged", file=sys.stderr)
                    print("   Then: REVIEW_TOKEN=<token> git commit -m 'message'", file=sys.stderr)
                    sys.exit(1)
                
                sys.path.insert(0, os.path.join(env['RY_LIBRARY_DIR'], 'lib'))
                from token_manager import verify_review_token
                
                if not verify_review_token(token):
                    print("‚ùå Invalid or expired token", file=sys.stderr)
                    print("   Run: git diff --staged", file=sys.stderr)
                    sys.exit(1)
                
                print("‚úÖ Review token verified", file=sys.stderr)
            
            # Validate and clean commit message
            - python: |
                import sys
                import os
                
                message = flags.get('m', '')
                
                sys.path.insert(0, os.path.join(env['RY_LIBRARY_DIR'], 'lib'))
                from commit_validator import process_commit_message
                
                cleaned, warnings = process_commit_message(message)
                
                # Show warnings but don't block
                for warning in warnings:
                    print(f"‚ö†Ô∏è  {warning}", file=sys.stderr)
                
                # Update the flag with cleaned message
                flags['m'] = cleaned
                if cleaned != message:
                    print(f"‚úèÔ∏è  Message cleaned", file=sys.stderr)
          
          relay: native
          
          after:
            - shell: |
                echo "‚úÖ Committed successfully" >&2

  # Tag with changelog integration for version tags
  tag:
    description: Create tags with automatic changelog release
    arguments:
      tagname: optional
    flags:
      m/message: string
      d/delete: bool
      l/list: bool
    
    handlers:
      # List or delete tags - just pass through
      - when: "flags.l or flags.d"
        relay: native
      
      # Create version tag with changelog
      - when: "arguments.tagname and not flags.d"
        augment:
          before:
            - python: |
                import sys
                import os
                import re
                import subprocess
                from pathlib import Path
                
                tag_name = arguments.get('tagname', '')
                
                # Check if it's a version tag
                version_pattern = r'^v?\d+\.\d+\.\d+'
                if not re.match(version_pattern, tag_name):
                    # Not a version tag, skip augmentation
                    sys.exit(0)
                
                # Extract version number
                version = tag_name[1:] if tag_name.startswith('v') else tag_name
                
                # Check for CHANGELOG.md
                if Path('CHANGELOG.md').exists():
                    print(f"üìù Releasing version {version} in changelog...", file=sys.stderr)
                    
                    # Call changelog release
                    result = subprocess.run(
                        ['ry-next', 'changelog', 'release', version],
                        capture_output=True,
                        text=True
                    )
                    
                    if result.returncode == 0:
                        # Commit the changelog update
                        subprocess.run(['/usr/bin/git', 'add', 'CHANGELOG.md'], check=False)
                        subprocess.run(
                            ['/usr/bin/git', 'commit', '-m', f'chore: release version {version}'],
                            check=False
                        )
                        print(f"‚úÖ Changelog updated for {version}", file=sys.stderr)
                    else:
                        print(f"‚ö†Ô∏è  Could not update changelog: {result.stderr}", file=sys.stderr)
          
          relay: native
          
          after:
            - shell: |
                echo "üì¶ Tagged: {{arguments.tagname}}" >&2
                echo "   Push with: git push origin {{arguments.tagname}}" >&2
      
      # Default: just pass through
      - default:
        relay: native

  # Push with branch protection
  push:
    description: Push with branch protection and preview support
    augment:
      before:
        - python: |
            import sys
            import subprocess
            
            # Skip warnings for --dry-run
            if flags.get('dry-run'):
                print("üîç Preview mode - showing what would be pushed", file=sys.stderr)
                sys.exit(0)  # Let native git handle the dry-run
            
            # Get current branch
            result = subprocess.run(
                ['/usr/bin/git', 'branch', '--show-current'],
                capture_output=True,
                text=True
            )
            
            branch = result.stdout.strip()
            
            # Check if pushing to protected branch
            protected = ['main', 'master']
            if branch in protected:
                # Only warn if not explicitly specified
                if branch not in str(remaining_args) and 'origin' not in str(remaining_args):
                    print(f"‚ö†Ô∏è  Direct push to {branch} branch", file=sys.stderr)
                    print(f"   Consider creating a feature branch:", file=sys.stderr)
                    print(f"     git checkout -b feature/name", file=sys.stderr)
                    print(f"     git push -u origin feature/name", file=sys.stderr)
                    print(f"   Or preview: git push --dry-run", file=sys.stderr)
                    print(f"   Or explicitly push: git push origin {branch}", file=sys.stderr)
                    # Don't block, just warn
      
      relay: native
      
      after:
        - python: |
            import sys
            
            # Success message (won't run for --dry-run as we exit early)
            if flags.get('tags') or flags.get('follow-tags'):
                print("‚úÖ Pushed with tags", file=sys.stderr)
            else:
                print("‚úÖ Pushed successfully", file=sys.stderr)
  
  # Add command - augment to show hint after staging
  add:
    relay: native
    augment:
      after:
        - shell: |
            if [ -n "$(/usr/bin/git diff --staged --name-only 2>/dev/null)" ]; then
                echo "üìù Files staged. Review with: git diff --staged" >&2
            fi
  
  # All other git commands automatically relay to native git